// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IntegrationMetadata integration metadata
//
// swagger:model IntegrationMetadata
type IntegrationMetadata struct {

	// Specifies the audited registry Id
	// Read Only: true
	AuditedRegistryID string `json:"auditedRegistryId,omitempty"`

	// Specifies the audited registry version
	// Read Only: true
	AuditedVersion string `json:"auditedVersion,omitempty"`

	// Specifies if the Applies To function is changed from origin or not
	// Read Only: true
	IsChangedFromOrigin *bool `json:"isChangedFromOrigin"`

	// Specifies if the Applies To function is changed from target last published or not
	// Read Only: true
	IsChangedFromTargetLastPublished *bool `json:"isChangedFromTargetLastPublished"`

	// The LocalModule Id
	// Read Only: true
	LocalModuleID int32 `json:"localModuleId,omitempty"`

	// The values can be DataSources | EventSources | PropertySources | ConfigSources | LogSources | TopologySources | Jobmonitors | AppliesTo Functions | SNMP SysOID Maps
	// The type of LogicModule
	// Read Only: true
	// Enum: [DATASOURCE EVENTSOURCE JOBMONITOR APPLIESTO_FUNCTION SNMP_SYSOID_MAP PROPERTYSOURCE CONFIGSOURCE TOPOLOGYSOURCE LOGSOURCE]
	LogicModuleType string `json:"logicModuleType,omitempty"`

	// Specifies the origin Author companies unique Id
	// Read Only: true
	OriginAuthorCompanyUUID string `json:"originAuthorCompanyUUID,omitempty"`

	// Specifies the origin Author companies namespace
	// Read Only: true
	OriginAuthorNamespace string `json:"originAuthorNamespace,omitempty"`

	// The metadata checksum for the LMModule content
	// Read Only: true
	OriginChecksum string `json:"originChecksum,omitempty"`

	// The origin lineage Id of the LMmodule
	// Read Only: true
	OriginLineageID string `json:"originLineageId,omitempty"`

	// Specifies the origin version locator
	// Read Only: true
	OriginLocator string `json:"originLocator,omitempty"`

	// Specifies the origin module name
	// Read Only: true
	OriginName string `json:"originName,omitempty"`

	// The Registry ID of the Exchange Integration this module is based from
	// Read Only: true
	OriginRegistryID string `json:"originRegistryId,omitempty"`

	// Specifies the origin version
	// Read Only: true
	OriginVersion string `json:"originVersion,omitempty"`

	// The metadata checksum for the target last published LMModule content
	// Read Only: true
	TargetLastPublishedChecksum string `json:"targetLastPublishedChecksum,omitempty"`

	// Specifies the target last published Id
	// Read Only: true
	TargetLastPublishedID string `json:"targetLastPublishedId,omitempty"`

	// Specifies the target last published version
	// Read Only: true
	TargetLastPublishedVersion string `json:"targetLastPublishedVersion,omitempty"`

	// Specifies the target lineage Id
	// Read Only: true
	TargetLineageID string `json:"targetLineageId,omitempty"`
}

// Validate validates this integration metadata
func (m *IntegrationMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLogicModuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var integrationMetadataTypeLogicModuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DATASOURCE","EVENTSOURCE","JOBMONITOR","APPLIESTO_FUNCTION","SNMP_SYSOID_MAP","PROPERTYSOURCE","CONFIGSOURCE","TOPOLOGYSOURCE","LOGSOURCE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		integrationMetadataTypeLogicModuleTypePropEnum = append(integrationMetadataTypeLogicModuleTypePropEnum, v)
	}
}

const (

	// IntegrationMetadataLogicModuleTypeDATASOURCE captures enum value "DATASOURCE"
	IntegrationMetadataLogicModuleTypeDATASOURCE string = "DATASOURCE"

	// IntegrationMetadataLogicModuleTypeEVENTSOURCE captures enum value "EVENTSOURCE"
	IntegrationMetadataLogicModuleTypeEVENTSOURCE string = "EVENTSOURCE"

	// IntegrationMetadataLogicModuleTypeJOBMONITOR captures enum value "JOBMONITOR"
	IntegrationMetadataLogicModuleTypeJOBMONITOR string = "JOBMONITOR"

	// IntegrationMetadataLogicModuleTypeAPPLIESTOFUNCTION captures enum value "APPLIESTO_FUNCTION"
	IntegrationMetadataLogicModuleTypeAPPLIESTOFUNCTION string = "APPLIESTO_FUNCTION"

	// IntegrationMetadataLogicModuleTypeSNMPSYSOIDMAP captures enum value "SNMP_SYSOID_MAP"
	IntegrationMetadataLogicModuleTypeSNMPSYSOIDMAP string = "SNMP_SYSOID_MAP"

	// IntegrationMetadataLogicModuleTypePROPERTYSOURCE captures enum value "PROPERTYSOURCE"
	IntegrationMetadataLogicModuleTypePROPERTYSOURCE string = "PROPERTYSOURCE"

	// IntegrationMetadataLogicModuleTypeCONFIGSOURCE captures enum value "CONFIGSOURCE"
	IntegrationMetadataLogicModuleTypeCONFIGSOURCE string = "CONFIGSOURCE"

	// IntegrationMetadataLogicModuleTypeTOPOLOGYSOURCE captures enum value "TOPOLOGYSOURCE"
	IntegrationMetadataLogicModuleTypeTOPOLOGYSOURCE string = "TOPOLOGYSOURCE"

	// IntegrationMetadataLogicModuleTypeLOGSOURCE captures enum value "LOGSOURCE"
	IntegrationMetadataLogicModuleTypeLOGSOURCE string = "LOGSOURCE"
)

// prop value enum
func (m *IntegrationMetadata) validateLogicModuleTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, integrationMetadataTypeLogicModuleTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IntegrationMetadata) validateLogicModuleType(formats strfmt.Registry) error {
	if swag.IsZero(m.LogicModuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLogicModuleTypeEnum("logicModuleType", "body", m.LogicModuleType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this integration metadata based on the context it is used
func (m *IntegrationMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuditedRegistryID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuditedVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsChangedFromOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsChangedFromTargetLastPublished(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalModuleID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicModuleType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginAuthorCompanyUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginAuthorNamespace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginChecksum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginLineageID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginLocator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginRegistryID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetLastPublishedChecksum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetLastPublishedID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetLastPublishedVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetLineageID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IntegrationMetadata) contextValidateAuditedRegistryID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "auditedRegistryId", "body", string(m.AuditedRegistryID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateAuditedVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "auditedVersion", "body", string(m.AuditedVersion)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateIsChangedFromOrigin(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isChangedFromOrigin", "body", m.IsChangedFromOrigin); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateIsChangedFromTargetLastPublished(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isChangedFromTargetLastPublished", "body", m.IsChangedFromTargetLastPublished); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateLocalModuleID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "localModuleId", "body", int32(m.LocalModuleID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateLogicModuleType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "logicModuleType", "body", string(m.LogicModuleType)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginAuthorCompanyUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originAuthorCompanyUUID", "body", string(m.OriginAuthorCompanyUUID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginAuthorNamespace(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originAuthorNamespace", "body", string(m.OriginAuthorNamespace)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginChecksum(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originChecksum", "body", string(m.OriginChecksum)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginLineageID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originLineageId", "body", string(m.OriginLineageID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginLocator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originLocator", "body", string(m.OriginLocator)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originName", "body", string(m.OriginName)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginRegistryID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originRegistryId", "body", string(m.OriginRegistryID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateOriginVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "originVersion", "body", string(m.OriginVersion)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateTargetLastPublishedChecksum(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetLastPublishedChecksum", "body", string(m.TargetLastPublishedChecksum)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateTargetLastPublishedID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetLastPublishedId", "body", string(m.TargetLastPublishedID)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateTargetLastPublishedVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetLastPublishedVersion", "body", string(m.TargetLastPublishedVersion)); err != nil {
		return err
	}

	return nil
}

func (m *IntegrationMetadata) contextValidateTargetLineageID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetLineageId", "body", string(m.TargetLineageID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IntegrationMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IntegrationMetadata) UnmarshalBinary(b []byte) error {
	var res IntegrationMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
