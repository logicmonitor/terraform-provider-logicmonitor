// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Website website
// Example: isResource
//
// swagger:model Website
type Website struct {

	// The description of the website
	// Example: Monitor Ebay site response times
	Description string `json:"description,omitempty"`

	// true: alerting is disabled for the website
	// false: alerting is enabled for the website
	// If stopMonitoring=true, then alerting will also by default be disabled for the website
	DisableAlerting bool `json:"disableAlerting,omitempty"`

	// Required for type=webcheck , The domain of the service. This is the base URL of the service
	// Example: www.ebay.com
	Domain string `json:"domain,omitempty"`

	// The number of test locations that checks must fail at to trigger an alert, where the alert triggered will be consistent with the value of overallAlertLevel. Possible values and corresponding number of Site Monitor locations are
	// 0 : all
	// 1 : half
	// 2 : more than one
	// 3 : any
	// Example: 0
	GlobalSmAlertCond int32 `json:"globalSmAlertCond,omitempty"`

	// The id of the group the website is in
	// Example: 1
	GroupID int32 `json:"groupId,omitempty"`

	// The URL to check, without the scheme or protocol (e.g http or https)
	// E.g. if the URL is "http://www.google.com, then the host="www.google.com"
	Host string `json:"host,omitempty"`

	// The id of the website
	// Read Only: true
	ID int32 `json:"id,omitempty"`

	// warn | error | critical
	// The level of alert to trigger if the website fails a check from an individual test location
	// Example: warn
	IndividualAlertLevel string `json:"individualAlertLevel,omitempty"`

	// true: an alert will be triggered if a check fails from an individual test location
	// false: an alert will not be triggered if a check fails from an individual test location
	// Example: false
	IndividualSmAlertEnable bool `json:"individualSmAlertEnable,omitempty"`

	// Whether or not the website is internal
	// Example: false
	IsInternal bool `json:"isInternal,omitempty"`

	// The time (in epoch format) that the website was updated
	// Read Only: true
	LastUpdated int64 `json:"lastUpdated,omitempty"`

	// The name of the website
	// Example: Ebay
	// Required: true
	Name *string `json:"name"`

	// warn | error | critical
	// The level of alert to trigger if the website fails the number of checks specified by transition from the test locations specified by globalSmAlertCond
	// Example: warn
	OverallAlertLevel string `json:"overallAlertLevel,omitempty"`

	// 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
	// The polling interval for the website, in units of minutes. This value indicates how often the website is checked. The minimum is 1 minute, and the maximum is 10 minutes
	// Example: 5
	PollingInterval int32 `json:"pollingInterval,omitempty"`

	// Whether is the website dead (the collector is down) or not
	// Read Only: true
	Status string `json:"status,omitempty"`

	// Required for type=webcheck , An object comprising one or more steps, see the table below for the properties included in each step
	Steps []*WebCheckStep `json:"steps"`

	// true: monitoring is disabled for the website
	// false: monitoring is enabled for the website
	// If stopMonitoring=true, then alerting will also by default be disabled for the website
	StopMonitoring bool `json:"stopMonitoring,omitempty"`

	// true: monitoring is disabled for all services in the website's folder
	// false: monitoring is not disabled for all services in website's folder
	// Read Only: true
	StopMonitoringByFolder *bool `json:"stopMonitoringByFolder,omitempty"`

	// The website template
	Template interface{} `json:"template,omitempty"`

	// The locations from which the website is monitored. If the website is internal, this field should include Collectors. If Non-Internal, possible test locations are:
	// 1 : US - LA
	// 2 : US - DC
	// 3 : US - SF
	// 4 : Europe - Dublin
	// 5 : Asia - Singapore
	// 6 : Australia - Sydney
	TestLocation *WebsiteLocation `json:"testLocation,omitempty"`

	// 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 30 | 60
	// The number of checks that must fail before an alert is triggered
	// Example: 1
	Transition int32 `json:"transition,omitempty"`

	// The type of the website. Acceptable values are: pingcheck, webcheck
	// Example: webcheck
	// Required: true
	Type *string `json:"type"`

	// true: The alert settings configured in the website Default Settings will be used
	// false: Service Default Settings will not be used, and you will need to specify individualSMAlertEnable, individualAlertLevel, globalSmAlertConf, overallAlertLevel and pollingInterval
	// Example: true
	UseDefaultAlertSetting bool `json:"useDefaultAlertSetting,omitempty"`

	// true: The checkpoint locations configured in the website Default Settings will be used
	// false: The checkpoint locations specified in the testLocation will be used
	// Example: false
	UseDefaultLocationSetting bool `json:"useDefaultLocationSetting,omitempty"`

	// write | read | ack. The permission level of the user that made the API request
	UserPermission string `json:"userPermission,omitempty"`
}

// Validate validates this website
func (m *Website) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Website) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Website) validateSteps(formats strfmt.Registry) error {
	if swag.IsZero(m.Steps) { // not required
		return nil
	}

	for i := 0; i < len(m.Steps); i++ {
		if swag.IsZero(m.Steps[i]) { // not required
			continue
		}

		if m.Steps[i] != nil {
			if err := m.Steps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Website) validateTestLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.TestLocation) { // not required
		return nil
	}

	if m.TestLocation != nil {
		if err := m.TestLocation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("testLocation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("testLocation")
			}
			return err
		}
	}

	return nil
}

func (m *Website) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this website based on the context it is used
func (m *Website) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStopMonitoringByFolder(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTestLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Website) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int32(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Website) contextValidateLastUpdated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastUpdated", "body", int64(m.LastUpdated)); err != nil {
		return err
	}

	return nil
}

func (m *Website) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Website) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if m.Steps[i] != nil {
			if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Website) contextValidateStopMonitoringByFolder(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stopMonitoringByFolder", "body", m.StopMonitoringByFolder); err != nil {
		return err
	}

	return nil
}

func (m *Website) contextValidateTestLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.TestLocation != nil {
		if err := m.TestLocation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("testLocation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("testLocation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Website) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Website) UnmarshalBinary(b []byte) error {
	var res Website
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
