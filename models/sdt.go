// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Sdt sdt
// Example: isResource
//
// swagger:model Sdt
type Sdt struct {

	// The name of the user that created the SDT
	// Read Only: true
	Admin string `json:"admin,omitempty"`

	// The name of the batchjob that the SDT will apply to
	BatchJobName string `json:"batchJobName,omitempty"`

	// The description of the collector that the SDT will be associated with
	// Read Only: true
	CollectorDescription string `json:"collectorDescription,omitempty"`

	// The id of the collector that the SDT will be associated with
	CollectorID int32 `json:"collectorId,omitempty"`

	// The notes associated with the SDT
	// Example: Emergency prod deployment
	Comment string `json:"comment,omitempty"`

	// The id of the datasource that this SDT will be associated with, for the specified group. dataSourceId 0 indicates all datasources
	DataSourceID int32 `json:"dataSourceId,omitempty"`

	// The id of the datasource instance that the SDT will be associated with
	DataSourceInstanceID int32 `json:"dataSourceInstanceId,omitempty"`

	// The name of the datasource instance that the SDT will be associated with
	DataSourceInstanceName string `json:"dataSourceInstanceName,omitempty"`

	// The name of the datasource that this SDT will be associated with, for the specified group. dataSourceName "All" indicates all datasources
	DataSourceName string `json:"dataSourceName,omitempty"`

	// default value
	// Format: date-time
	DefaultValue strfmt.DateTime `json:"defaultValue,omitempty"`

	// The id of the device batchjob that the SDT will be associated with
	DeviceBatchJobID int32 `json:"deviceBatchJobId,omitempty"`

	// The id of the device datasource that the SDT will be associated with
	DeviceDataSourceID int32 `json:"deviceDataSourceId,omitempty"`

	// The name of the device datasource instance group that the SDT will be associated with
	DeviceDataSourceInstanceGroupID int32 `json:"deviceDataSourceInstanceGroupId,omitempty"`

	// The name of the instance group
	DeviceDataSourceInstanceGroupName string `json:"deviceDataSourceInstanceGroupName,omitempty"`

	// The name of the device that this SDT will be associated with
	DeviceDisplayName string `json:"deviceDisplayName,omitempty"`

	// The id of the device eventsource that the SDT will be associated with
	DeviceEventSourceID int32 `json:"deviceEventSourceId,omitempty"`

	// The full path of the device group that this SDT will be associated with
	DeviceGroupFullPath string `json:"deviceGroupFullPath,omitempty"`

	// The id of the device group that the SDT will be associated with
	DeviceGroupID int32 `json:"deviceGroupId,omitempty"`

	// The id of the device that the SDT will be associated with
	DeviceID int32 `json:"deviceId,omitempty"`

	// The duration of the SDT in minutes
	// Example: 138
	Duration int32 `json:"duration,omitempty"`

	// The epoch time, in milliseconds, that the SDT will end
	// Example: 1534554000000
	EndDateTime int64 `json:"endDateTime,omitempty"`

	// The date, time and time zone that the SDT will end at
	// Read Only: true
	EndDateTimeOnLocal string `json:"endDateTimeOnLocal,omitempty"`

	// The values can be 1 | 2....| 24. Specifies the hour that the SDT ends for a repeating SDT
	// Example: 5
	EndHour int32 `json:"endHour,omitempty"`

	// The values can be 1 | 2....| 60. Specifies the minute of the hour that the SDT ends for a repeating SDT
	// Example: 18
	EndMinute int32 `json:"endMinute,omitempty"`

	// The name of the eventsource that the SDT will apply to
	EventSourceName string `json:"eventSourceName,omitempty"`

	// The values can be 1 | 2....| 24. Specifies the hour that the SDT will start for a repeating SDT (daily, weekly, or monthly)
	// Example: 3
	Hour int32 `json:"hour,omitempty"`

	// The Id of the SDT. This value will be in the following format "XX_##" where XX will refer to the type of SDT and ## will refer to the number of SDTs of that type
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The values can be true|false, where true: the SDT is currently active
	// false: the SDT is currently inactive
	// Read Only: true
	IsEffective *bool `json:"isEffective,omitempty"`

	// The values can be 1 | 2....| 60. Specifies the minute of the hour that the SDT should begin for a repeating SDT
	// Example: 6
	Minute int32 `json:"minute,omitempty"`

	// The values can be 1 | 2....| 31. Specifies the day of the month that the SDT will be active for a monthly SDT
	// Example: 7
	MonthDay int32 `json:"monthDay,omitempty"`

	// The type of sdt. The values can be oneTime|weekly|monthly|daily|monthlyByWeek
	// Example: oneTime
	SdtType string `json:"sdtType,omitempty"`

	// The epoch time, in milliseconds, that the SDT will start
	// Example: 1534460400000
	StartDateTime int64 `json:"startDateTime,omitempty"`

	// The date, time and time zone that the SDT will end at
	// Read Only: true
	StartDateTimeOnLocal string `json:"startDateTimeOnLocal,omitempty"`

	// The specific timezone for SDT
	// Example: America/Los_Angeles
	Timezone string `json:"timezone,omitempty"`

	// The type of resource that this SDT is for. The values can be CollectorSDT | DeviceDataSourceInstanceSDT | DeviceBatchJobSDT | DeviceClusterAlertDefSDT | DeviceDataSourceInstanceGroupSDT | DeviceDataSourceSDT | DeviceEventSourceSDT | ResourceGroupSDT | ResourceSDT | WebsiteCheckpointSDT | WebsiteGroupSDT | WebsiteSDT | DeviceLogPipeLineResourceSDT
	// Example: ResourceGroupSDT
	// Required: true
	Type *string `json:"type"`

	// The week day of sdt. The values can be SUNDAY|MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY
	// Example: Sunday
	WeekDay string `json:"weekDay,omitempty"`

	// The week of the month that the SDT will be active for a monthly SDT
	// Example: 1
	WeekOfMonth string `json:"weekOfMonth,omitempty"`
}

// Validate validates this sdt
func (m *Sdt) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Sdt) validateDefaultValue(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultValue) { // not required
		return nil
	}

	if err := validate.FormatOf("defaultValue", "body", "date-time", m.DefaultValue.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this sdt based on the context it is used
func (m *Sdt) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdmin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCollectorDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEndDateTimeOnLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsEffective(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartDateTimeOnLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Sdt) contextValidateAdmin(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "admin", "body", string(m.Admin)); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) contextValidateCollectorDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "collectorDescription", "body", string(m.CollectorDescription)); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) contextValidateEndDateTimeOnLocal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "endDateTimeOnLocal", "body", string(m.EndDateTimeOnLocal)); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) contextValidateIsEffective(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isEffective", "body", m.IsEffective); err != nil {
		return err
	}

	return nil
}

func (m *Sdt) contextValidateStartDateTimeOnLocal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "startDateTimeOnLocal", "body", string(m.StartDateTimeOnLocal)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Sdt) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Sdt) UnmarshalBinary(b []byte) error {
	var res Sdt
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
